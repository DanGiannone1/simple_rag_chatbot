Here is my codebase:

<File: backend/app.py>
from flask import Flask, request, jsonify, Response, send_from_directory
import google.generativeai as genai
import os
from dotenv import load_dotenv
from flask_cors import CORS
import json
from document_processor import DocumentProcessor

# Load environment variables
load_dotenv()

app = Flask(__name__, static_folder='static')
CORS(app)  # Enable CORS for all routes

# Initialize Gemini with API key
genai.configure(api_key=os.getenv('GOOGLE_API_KEY'))

# Initialize the model and document processor
model = genai.GenerativeModel('gemini-pro')
doc_processor = DocumentProcessor(
    source_dir="../data/source_files",
    db_dir="../data/vector_db"
)

# Serve static files
@app.route('/')
def serve_index():
    return send_from_directory(app.static_folder, 'index.html')

@app.route('/<path:path>')
def serve_static(path):
    return send_from_directory(app.static_folder, path)

@app.route('/process-docs', methods=['POST'])
def process_documents():
    """Endpoint to process/reprocess all documents"""
    try:
        overwrite = request.json.get('overwrite', False) if request.json else False
        doc_processor.process_pdfs(overwrite=overwrite)
        return jsonify({'message': 'Documents processed successfully'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

#API route for chat
@app.route('/chat', methods=['POST'])
def chat():
    try:
        data = request.json
        user_message = data.get('message')
        print(f"\nUser message: {user_message}")
        
        if not user_message:
            return jsonify({'error': 'No message provided'}), 400

        # Get relevant document chunks
        relevant_docs = doc_processor.query_similar(user_message)
        
        # Print chunks for debugging
        print("\nRelevant chunks found:")
        for i, doc in enumerate(relevant_docs, 1):
            print(f"\n[{i}] From {doc['source']}, Page {doc['page']}:")
            print("-" * 50)
            print(doc['content'])
            print("-" * 50)
        
        # Format context with citations
        context_parts = []
        citations = []  # Store citations for frontend
        for i, doc in enumerate(relevant_docs, 1):
            context_parts.append(f"[{i}] From {doc['source']}, Page {doc['page']}:\n{doc['content']}")
            citations.append({
                'id': i,
                'source': doc['source'],
                'page': doc['page'],
                'content': doc['content']
            })
        context = "\n\n".join(context_parts)
        
        def generate():
            # Generate streaming response using Gemini
            prompt = f"""Please provide a response using the following context and format it using markdown syntax where appropriate. If the context doesn't help answer the question, just respond based on your general knowledge.

When you use information from the context, please cite the source using the number in brackets [1], [2], etc.

Context:
{context}

User Question:
{user_message}

Please provide a well-structured response with appropriate citations."""

            response = model.generate_content(prompt, stream=True)
            
            # Send citations first
            yield f"data: {json.dumps({'citations': citations})}\n\n"
            
            for chunk in response:
                if chunk.text:
                    # Format the data as SSE
                    data = json.dumps({'chunk': chunk.text})
                    yield f"data: {data}\n\n"
            
            # Send a completion message
            yield "data: [DONE]\n\n"

        return Response(generate(), mimetype='text/event-stream')
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
--------------------------------------------------------------------------------
<File: backend/document_processor.py>
from langchain.document_loaders import PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_google_genai import GoogleGenerativeAIEmbeddings
from langchain.vectorstores import Chroma
import os
import shutil
from dotenv import load_dotenv
import argparse

load_dotenv()

class DocumentProcessor:
    def __init__(self, source_dir="../data/source_files", db_dir="../data/vector_db"):
        self.source_dir = source_dir
        self.db_dir = db_dir
        self.embeddings = GoogleGenerativeAIEmbeddings(
            model="models/embedding-001",
            google_api_key=os.getenv("GOOGLE_API_KEY")
        )
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            length_function=len,
        )
        
    def clear_database(self):
        """Clear all data from the vector database."""
        if os.path.exists(self.db_dir):
            print(f"Clearing existing database at {self.db_dir}")
            shutil.rmtree(self.db_dir)
            os.makedirs(self.db_dir)
            print("Database cleared successfully")
        
    def process_pdfs(self, overwrite=False):
        """Process all PDFs in the source directory and store them in the vector database.
        
        Args:
            overwrite (bool): If True, clear existing database before processing.
        """
        if overwrite:
            self.clear_database()
            
        documents = []
        
        # Load all PDFs from the source directory
        pdf_files = [f for f in os.listdir(self.source_dir) if f.endswith(".pdf")]
        if not pdf_files:
            print(f"No PDF files found in {self.source_dir}")
            return None
            
        print(f"Found {len(pdf_files)} PDF files to process...")
        
        for filename in pdf_files:
            file_path = os.path.join(self.source_dir, filename)
            print(f"Processing {filename}...")
            loader = PyPDFLoader(file_path)
            # PyPDFLoader automatically includes page numbers in metadata
            docs = loader.load()
            # Add source filename to metadata
            for doc in docs:
                doc.metadata["source"] = filename
            documents.extend(docs)
        
        print("Splitting documents into chunks...")
        # Split documents into chunks while preserving metadata
        texts = self.text_splitter.split_documents(documents)
        
        print("Creating vector store...")
        # Create or load the vector store
        db = Chroma.from_documents(
            documents=texts,
            embedding=self.embeddings,
            persist_directory=self.db_dir
        )
        db.persist()
        print(f"Successfully processed {len(pdf_files)} files and created {len(texts)} chunks")
        return db
    
    def query_similar(self, query: str, k: int = 3):
        """Query the vector store for similar chunks of text."""
        db = Chroma(
            persist_directory=self.db_dir,
            embedding_function=self.embeddings
        )
        results = db.similarity_search(query, k=k)
        # Format results with metadata
        formatted_results = []
        for doc in results:
            formatted_results.append({
                'content': doc.page_content,
                'source': doc.metadata.get('source', 'Unknown'),
                'page': doc.metadata.get('page', 1)
            })
        return formatted_results

def main():
    parser = argparse.ArgumentParser(description='Process PDF documents for RAG system')
    parser.add_argument('--source-dir', type=str, default='../data/source_files',
                      help='Directory containing PDF files (default: ../data/source_files)')
    parser.add_argument('--db-dir', type=str, default='../data/vector_db',
                      help='Directory to store vector database (default: ../data/vector_db)')
    parser.add_argument('--test-query', type=str,
                      help='Optional test query to try after processing')
    parser.add_argument('--overwrite', action='store_true',
                      help='Overwrite existing database instead of updating it')
    
    args = parser.parse_args()
    
    processor = DocumentProcessor(source_dir=args.source_dir, db_dir=args.db_dir)
    
    print("Starting document processing...")
    processor.process_pdfs(overwrite=args.overwrite)
    
    if args.test_query:
        print(f"\nTesting with query: {args.test_query}")
        results = processor.query_similar(args.test_query)
        print("\nTop relevant chunks:")
        for i, doc in enumerate(results, 1):
            print(f"\n--- Chunk {i} from {doc['source']}, Page {doc['page']} ---")
            print(doc['content'][:200] + "..." if len(doc['content']) > 200 else doc['content'])

if __name__ == "__main__":
    main() 
--------------------------------------------------------------------------------
<File: backend/requirements.txt>
flask
python-dotenv
google-generativeai
flask-cors
pypdf
langchain
chromadb
tiktoken
langchain-community
langchain-google-genai


--------------------------------------------------------------------------------
<File: frontend/package.json>
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@mantine/core": "^7.15.2",
    "@mantine/hooks": "^7.15.2",
    "@tabler/icons-react": "^3.26.0",
    "@types/react-syntax-highlighter": "^15.5.13",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-markdown": "^8.0.7",
    "react-syntax-highlighter": "^15.6.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.18.2",
    "vite": "^6.0.5"
  }
}

--------------------------------------------------------------------------------
<File: frontend/README.md>
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

--------------------------------------------------------------------------------
<File: frontend/src/App.css>
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--------------------------------------------------------------------------------
<File: frontend/src/App.tsx>
import { MantineProvider, AppShell, Container } from '@mantine/core';
import ChatInterface from './components/chat/ui/ChatInterface';
import '@mantine/core/styles.css';

function App() {
  return (
    <MantineProvider defaultColorScheme="dark">
      <AppShell
        style={{
          backgroundColor: 'var(--app-bg)',
          minHeight: '100vh',
        }}
      >
        <Container 
          size="md" 
          h="100vh" 
          p="md" 
          style={{ 
            display: 'flex',
            flexDirection: 'column',
          }}
        >
          <ChatInterface />
        </Container>
      </AppShell>
    </MantineProvider>
  );
}

export default App;

--------------------------------------------------------------------------------
<File: frontend/src/components/chat/hooks/useChat.ts>
import { useState } from 'react';
import { Message } from '../types';

export const useChat = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);

  const handleSend = async () => {
    if (!input.trim() || isTyping) return;

    const userMessage: Message = {
      text: input,
      isBot: false,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsTyping(true);

    try {
      const tempBotMessage: Message = {
        text: '',
        isBot: true,
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, tempBotMessage]);

      const response = await fetch('/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: input }),
      });

      if (!response.ok) {
        throw new Error('Failed to get response');
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('Failed to initialize stream reader');
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') {
              console.log('Stream completed. Final message:', messages[messages.length - 1]);
              break;
            }

            try {
              const parsedData = JSON.parse(data);
              console.log('Received data:', parsedData);
              
              setMessages(prev => {
                const newMessages = [...prev];
                const lastMessage = newMessages[newMessages.length - 1];
                if (lastMessage.isBot) {
                  if (parsedData.citations) {
                    console.log('Adding citations:', parsedData.citations);
                    lastMessage.citations = parsedData.citations;
                  } else if (parsedData.chunk) {
                    console.log('Adding chunk:', parsedData.chunk);
                    lastMessage.text += parsedData.chunk;
                  }
                  console.log('Updated message:', lastMessage);
                }
                return newMessages;
              });
            } catch (e) {
              console.error('Failed to parse chunk:', e);
            }
          }
        }
      }

    } catch (error) {
      console.error('Chat error:', error);
      const errorMessage: Message = {
        text: `Error: ${error instanceof Error ? error.message : 'Failed to get response'}`,
        isBot: true,
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };

  return {
    messages,
    input,
    isTyping,
    setInput,
    handleSend,
  };
}; 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/types/index.ts>
export interface Message {
  text: string;
  isBot: boolean;
  timestamp: Date;
  citations?: Citation[];
}

export interface Citation {
  id: number;
  source: string;
  page: number;
  content: string;
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/ui/ChatInput.tsx>
import { Box, TextInput, Group, ActionIcon, Paper } from '@mantine/core';
import { IconSend } from '@tabler/icons-react';

interface ChatInputProps {
  input: string;
  isTyping: boolean;
  onInputChange: (value: string) => void;
  onSend: () => void;
}

export function ChatInput({ input, isTyping, onInputChange, onSend }: ChatInputProps) {
  return (
    <Paper
      p="md"
      radius={0}
      style={{
        borderTop: '1px solid var(--border-color)',
        backgroundColor: 'var(--input-bg)',
        position: 'relative',
      }}
    >
      <Box style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <Group gap={8} align="center" style={{ position: 'relative' }}>
          <TextInput
            placeholder="Type your message..."
            value={input}
            onChange={(e) => onInputChange(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && onSend()}
            size="lg"
            radius="xl"
            disabled={isTyping}
            style={{ flex: 1 }}
            styles={{
              input: {
                backgroundColor: 'var(--container-bg)',
                border: '1px solid var(--border-color)',
                '&:focus': {
                  borderColor: 'var(--mantine-color-blue-filled)',
                },
                fontSize: '1rem',
                padding: '1.2rem',
                height: 'auto',
                paddingRight: '3.5rem',
                color: 'var(--text-bright)',
                '&::placeholder': {
                  color: 'var(--text-secondary)',
                }
              }
            }}
          />
          <ActionIcon
            size="lg"
            radius="xl"
            color="blue"
            variant="subtle"
            onClick={onSend}
            disabled={isTyping}
            style={{ 
              position: 'absolute',
              right: '0.5rem',
              backgroundColor: input.trim() ? 'var(--mantine-color-blue-filled)' : 'transparent',
              color: input.trim() ? 'white' : 'var(--mantine-color-blue-filled)',
              transition: 'all 0.2s ease',
              '&:hover': {
                backgroundColor: input.trim() ? 'var(--mantine-color-blue-filled-hover)' : 'var(--mantine-color-blue-light)',
              }
            }}
          >
            <IconSend size="1.2rem" />
          </ActionIcon>
        </Group>
      </Box>
    </Paper>
  );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/ui/ChatInterface.tsx>
import { Paper, ScrollArea, Stack, Title } from '@mantine/core';
import { useChat } from '../hooks/useChat';
import { EmptyState } from './EmptyState';
import { MessageBubble } from './MessageBubble';
import { ChatInput } from './ChatInput';

export default function ChatInterface() {
  const { messages, input, isTyping, setInput, handleSend } = useChat();

  return (
    <Paper
      style={{
        height: '100%',
        backgroundColor: 'var(--container-bg)',
        border: '1px solid var(--border-color)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}
      radius="lg"
      shadow="md"
    >
      <Title
        order={2}
        ta="center"
        py="sm"
        style={{
          borderBottom: '1px solid var(--border-color)',
          backgroundColor: 'var(--header-bg)',
          color: 'var(--text-bright)',
        }}
      >
        AI Chat Assistant
      </Title>

      <ScrollArea 
        flex={1}
        type="hover"
        offsetScrollbars
        scrollbarSize={8}
        style={{ backgroundColor: 'var(--chat-bg)', width: '100%' }}
      >
        <Stack gap="md" p="md" style={{ width: '100%' }}>
          {messages.length === 0 ? (
            <EmptyState />
          ) : (
            <>
              {messages.map((message, index) => (
                <MessageBubble key={index} message={message} />
              ))}
            </>
          )}
        </Stack>
      </ScrollArea>

      <ChatInput
        input={input}
        isTyping={isTyping}
        onInputChange={setInput}
        onSend={handleSend}
      />
    </Paper>
  );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/ui/CitationSidebar.tsx>
import { Paper, Text, Stack, ScrollArea, Title, Group } from '@mantine/core';
import { Citation } from '../types';

interface CitationSidebarProps {
  citation: Citation | null;
}

export function CitationSidebar({ citation }: CitationSidebarProps) {
  if (!citation) return null;

  return (
    <Paper
      p="md"
      style={{
        width: '400px',
        height: '100%',
        backgroundColor: 'var(--container-bg)',
        borderLeft: '1px solid var(--border-color)',
      }}
    >
      <Stack h="100%">
        <Title order={3} style={{ color: 'var(--text-bright)' }}>Citation Details</Title>
        <Group justify="space-between" align="center">
          <Text fw={500} size="sm" style={{ color: 'var(--text-bright)' }}>
            Source: {citation.source}
          </Text>
          <Text size="xs" c="dimmed">Page {citation.page}</Text>
        </Group>
        <ScrollArea flex={1}>
          <Paper 
            withBorder 
            p="md" 
            style={{ 
              backgroundColor: 'var(--message-bot-bg)',
              color: 'var(--text-bright)',
            }}
          >
            <Text size="sm" style={{ whiteSpace: 'pre-wrap', lineHeight: 1.6 }}>
              {citation.content}
            </Text>
          </Paper>
        </ScrollArea>
      </Stack>
    </Paper>
  );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/ui/EmptyState.tsx>
import { Box, Text } from '@mantine/core';
import { IconRobot } from '@tabler/icons-react';

export function EmptyState() {
  return (
    <Box 
      style={{ 
        textAlign: 'center', 
        padding: '4rem 1rem',
        color: 'var(--text-secondary)',
      }}
    >
      <IconRobot size={48} style={{ marginBottom: '1rem', opacity: 0.5 }} />
      <Text size="lg">Start a conversation...</Text>
      <Text size="sm" c="dimmed">Type a message below to begin</Text>
    </Box>
  );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/ui/MarkdownComponents.tsx>
import { Box, Text, Title } from '@mantine/core';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { Message, Citation } from '../types';

interface MarkdownComponentsProps {
  message: Message;
  onCitationClick: (citation: Citation) => void;
}

export const createMarkdownComponents = ({ message, onCitationClick }: MarkdownComponentsProps) => ({
  code: ({inline, className, children}: {inline?: boolean, className?: string, children: React.ReactNode}) => {
    const match = /language-(\w+)/.exec(className || '');
    return !inline && match ? (
      <SyntaxHighlighter
        style={oneDark}
        language={match[1]}
        customStyle={{
          margin: '0.5rem 0',
          borderRadius: '4px',
        }}
      >
        {String(children).replace(/\n$/, '')}
      </SyntaxHighlighter>
    ) : (
      <code 
        className={className}
        style={{
          backgroundColor: 'var(--container-bg)',
          padding: '0.2rem 0.4rem',
          borderRadius: '4px',
          fontSize: '0.9em',
        }}
      >
        {children}
      </code>
    );
  },

  text: ({children}: {children: React.ReactNode}) => {
    if (typeof children !== 'string') return <>{children}</>;
    
    const parts = children.split(/(\[\d+\])/g);
    console.log('Split text into parts:', parts);
    
    return (
      <span style={{ color: 'var(--text-bright)' }}>
        {parts.map((part, index) => {
          const citationMatch = part.match(/\[(\d+)\]/);
          if (!citationMatch) return part;
          
          const citationId = parseInt(citationMatch[1]);
          console.log('Found citation:', citationId);
          const citation = message.citations?.find(c => c.id === citationId);
          console.log('Matching citation object:', citation);
          
          if (!citation) return part;
          
          return (
            <Text 
              key={index}
              component="span" 
              c="blue.5"
              style={{ 
                cursor: 'pointer', 
                textDecoration: 'underline',
                display: 'inline-block'
              }}
              onClick={() => {
                console.log('Citation clicked:', citation);
                onCitationClick(citation);
              }}
            >
              {part}
            </Text>
          );
        })}
      </span>
    );
  },

  p: ({children}: {children: React.ReactNode}) => (
    <Text 
      size="sm" 
      style={{ 
        margin: '0.5rem 0',
        lineHeight: 1.6,
        color: 'var(--text-bright)',
      }}
    >
      {children}
    </Text>
  ),

  h1: ({children}: {children: React.ReactNode}) => (
    <Title order={1} style={{ margin: '1rem 0 0.5rem', fontSize: '1.5rem', color: 'var(--text-bright)' }}>
      {children}
    </Title>
  ),

  h2: ({children}: {children: React.ReactNode}) => (
    <Title order={2} style={{ margin: '1rem 0 0.5rem', fontSize: '1.3rem', color: 'var(--text-bright)' }}>
      {children}
    </Title>
  ),

  ul: ({children}: {children: React.ReactNode}) => (
    <Box component="ul" style={{ margin: '0.5rem 0', paddingLeft: '1.5rem' }}>
      {children}
    </Box>
  ),

  li: ({children}: {children: React.ReactNode}) => (
    <Box 
      component="li" 
      style={{ 
        margin: '0.25rem 0',
        color: 'var(--text-bright)',
        fontSize: '0.875rem',
        lineHeight: 1.6,
      }}
    >
      {children}
    </Box>
  ),
}); 
--------------------------------------------------------------------------------
<File: frontend/src/components/chat/ui/MessageBubble.tsx>
import { Paper, Text, ActionIcon, Group } from '@mantine/core';
import { IconRobot, IconUser } from '@tabler/icons-react';
import ReactMarkdown from 'react-markdown';
import { Message, Citation } from '../types';
import { createMarkdownComponents } from './MarkdownComponents';
import { CitationSidebar } from './CitationSidebar';
import { useState } from 'react';

interface MessageBubbleProps {
  message: Message;
}

export function MessageBubble({ message }: MessageBubbleProps) {
  const [selectedCitation, setSelectedCitation] = useState<Citation | null>(null);

  return (
    <Group wrap="nowrap" gap="sm" align="flex-start" style={{ width: '100%' }}>
      <Group
        wrap="nowrap"
        gap="sm"
        justify={message.isBot ? 'flex-start' : 'flex-end'}
        align="flex-start"
        style={{ flex: 1 }}
      >
        {message.isBot && (
          <ActionIcon
            variant="subtle"
            color="blue"
            size="lg"
            radius="xl"
            style={{ backgroundColor: 'var(--icon-bg)' }}
          >
            <IconRobot style={{ width: 'calc(1.2rem * var(--mantine-scale))', height: 'calc(1.2rem * var(--mantine-scale))' }} />
          </ActionIcon>
        )}

        <Paper
          p="sm"
          radius="md"
          style={{
            backgroundColor: message.isBot ? 'var(--message-bot-bg)' : 'var(--mantine-color-blue-filled)',
            maxWidth: selectedCitation ? '50%' : '70%',
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
          }}
        >
          {message.isBot ? (
            <ReactMarkdown
              components={createMarkdownComponents({
                message,
                onCitationClick: setSelectedCitation,
              })}
              className="markdown-content"
              remarkPlugins={[]}
              rehypePlugins={[]}
            >
              {message.text}
            </ReactMarkdown>
          ) : (
            <Text 
              size="sm" 
              style={{ 
                whiteSpace: 'pre-wrap', 
                lineHeight: 1.5,
                color: 'white',
              }}
            >
              {message.text}
            </Text>
          )}
          <Text 
            size="xs" 
            style={{ 
              opacity: 0.7, 
              textAlign: 'right',
              marginTop: '4px',
              color: message.isBot ? 'var(--text-secondary)' : 'var(--mantine-color-white-alpha-70)',
            }}
          >
            {message.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
          </Text>
        </Paper>

        {!message.isBot && (
          <ActionIcon
            variant="subtle"
            color="blue"
            size="lg"
            radius="xl"
            style={{ backgroundColor: 'var(--icon-bg)' }}
          >
            <IconUser style={{ width: 'calc(1.2rem * var(--mantine-scale))', height: 'calc(1.2rem * var(--mantine-scale))' }} />
          </ActionIcon>
        )}
      </Group>

      {selectedCitation && (
        <CitationSidebar citation={selectedCitation} />
      )}
    </Group>
  );
} 
--------------------------------------------------------------------------------
<File: frontend/src/index.css>
@import '@mantine/core/styles.css';

:root {
  /* Base colors */
  --app-bg: #1A1B1E;
  --container-bg: #25262B;
  --header-bg: #2C2E33;
  --chat-bg: #1F2023;
  --input-bg: #25262B;
  --border-color: #2C2E33;
  
  /* Message colors */
  --message-bot-bg: #2C2E33;
  --message-user-bg: #228BE6;
  --icon-bg: rgba(76, 110, 245, 0.1);
  
  /* Text colors */
  --text-bright: #FFFFFF;
  --text-primary: #C1C2C5;
  --text-secondary: #909296;

  /* Input colors */
  --input-text: #FFFFFF;
  --input-placeholder: #909296;
  --input-border-focus: #228BE6;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100vh;
  width: 100%;
  background-color: var(--app-bg);
  color: var(--text-primary);
}

#root {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Input placeholder styling */
input::placeholder {
  color: var(--input-placeholder) !important;
  opacity: 0.7;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-secondary);
}

@keyframes bounce {
  0%, 60%, 100% {
    transform: translateY(0);
  }
  30% {
    transform: translateY(-4px);
  }
}

--------------------------------------------------------------------------------
<File: frontend/src/main.tsx>
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

--------------------------------------------------------------------------------
<File: frontend/src/vite-env.d.ts>
/// <reference types="vite/client" />

--------------------------------------------------------------------------------
<File: frontend/tsconfig.app.json>
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.json>
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.node.json>
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

--------------------------------------------------------------------------------
<File: README.md>
# simple_rag_chatbot
--------------------------------------------------------------------------------

<end codebase> 

